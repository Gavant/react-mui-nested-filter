Can you help me write a readme for a component? This the topmost parent:
```
export interface FilterProps {
    checkboxSize: MuiCheckboxSizes;
    initialCheckedItems?: CheckedItemsType;
    controlledCheckedItems?: CheckedItemsType;
    onFilterChange: (updatedFilters: CheckedItemsType) => void;
    options?: FilterOptions; // Add a specific type for options
    children: ReactNode | ReactNode[];
}

function Filters<T extends boolean>({
    checkboxSize = 'medium',
    initialCheckedItems,
    onFilterChange,
    controlledCheckedItems,
    options = { replaceChildrenWithParentOnAllChecked: true, combineChildrenAndParentItems: true } as FilterOptions & {
        combineChildrenAndParentItems: T;
    },
    children,
}: FilterProps) {
    const isControlled = controlledCheckedItems !== undefined;
    const [items, setItems] = useState<Record<string, { isExpanded: boolean }>>({});
    const [expandedItems, setExpandedItems] = useState<Set<string>>(new Set());
    const [checkedItems, setCheckedItemsWrapped] = useState<CheckedItemsType>(() => initialCheckedItems ?? {});
    const currentCheckedItems = isControlled ? controlledCheckedItems : checkedItems;

    .
    .
    >

    const onItemChecked = (key: string, update: Record<string, Set<string>>) => {
        const result = setCheckedItems(key, update);

        onFilterChange(result);
    };

    const contextValue = {
        checkboxSize,
        expandedItems,
        checkedItems: currentCheckedItems,
        onItemExpansionToggle: handleItemExpansionToggle,
        onItemChecked,
        options,
        defaultBuckets: DEFAULT_BUCKETS,
        createDefaultBuckets,
    };

    return (
        <FilterContext.Provider value={contextValue}>
            <SimpleTreeView expandedItems={Array.from(expandedItems)} onItemExpansionToggle={handleItemExpansionToggle}>
                {children}
            </SimpleTreeView>
        </FilterContext.Provider>
    );
}
```

This is the partial of one child, Nested Filter:
```
export interface ParentType extends Record<string, string> {}
export interface ChildType extends Record<string, string> {}

type Value<V> = V[keyof V];

export type MappingKey<I> = Value<I>;
type MappingValue<C> = Array<C[keyof C]>;
type MappingType<I extends ParentType, C extends ChildType> = Partial<Record<MappingKey<I>, MappingValue<C>>>;

type NestedFilterProps<I extends ParentType, C extends ChildType, M extends MappingType<I, C>> = {
    filterKey: string;
    items: I;
    childItems: C;
    mapping: M;
    parentSort?: Record<Value<I>, number>;
    childSort?: Record<Value<I>, number>;
    labelOverrides?: Partial<Record<Value<I> | Value<C>, string>>;
    options?: FilterOptions;
};

function NestedFilter<I extends ParentType, C extends ChildType, M extends MappingType<I, C>>({
    filterKey,
    items,
    childItems,
    mapping,
    parentSort,
    childSort,
    labelOverrides,
}: NestedFilterProps<I, C, M>) {
```

And the other child:
```
function StandaloneFilter({ id, filterKey, title, value, groupWithChildren = false }: FilterItemInterface) {
    const { checkedItems, onItemChecked, defaultBuckets, checkboxSize } = useFilterContext();
    const thisFilterItems = checkedItems?.[filterKey] ?? createDefaultBuckets();

    const getBucket = useCallback(() => (groupWithChildren ? defaultBuckets.child : defaultBuckets.parent), [groupWithChildren]);

    const onCheckedChange = (isChecked: boolean) => {
        const checkedUpdate = thisFilterItems;
        if (isChecked) {
            checkedUpdate?.[getBucket()].add(value);
        } else {
            checkedUpdate?.[getBucket()].delete(value);
        }

        onItemChecked(filterKey, thisFilterItems);
    };

    return (
        <FilterItem
            size={checkboxSize}
            title={title}
            itemId={id}
            id={id}
            isChecked={thisFilterItems?.[getBucket()].has(value)}
            onChecked={onCheckedChange}
        />
    );
}
```

The data:
```
export enum PetType {
    .
    .
    Cat = 'CAT',
    .
    .
}

export enum PetBreed {
    Abyssinian = 'ABYSSINIAN',
    .
    .
}

const petBreedMapping: Record<PetBreed, PetType> = {
    ABYSSINIAN: PetType.Cat
    .
    .
    .
};

export const breedMapping: Record<Exclude<PetType, PetType.Other>, PetBreed[]> = {
    [PetType.Cat]: [PetBreed.Abyssinian],
    .
    .
    .
};


export const sort = {
    .
    .
    [PetType.Cat]: 2,
    .
    .
    [PetType.Other]: 8,
};

export const Overrides = {
    [PetType.Cat]: 'Mean Angry Felines',
};
```

and the Implementation:
```
 <Filters
    {...restArgs}
    checkboxSize={args.checkboxSize}
    initialCheckedItems={CheckedItems}
    onFilterChange={handleFilterChange}
    options={updatedOptions}
>
    <NestedFilter
        filterKey="PetTypeBreed"
        items={PetType}
        childItems={PetBreed}
        mapping={breedMapping}
        labelOverrides={Overrides}
        parentSort={sort}
    />
    <StandaloneFilter filterKey="PetTypeBreed" id="other" title="Other" value="OTHER" />
</Filters>
```
